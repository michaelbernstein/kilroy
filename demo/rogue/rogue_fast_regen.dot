digraph rogue_fast_regen {
    graph [
        goal="Port the classic Rogue 5.4.4 game from C to Rust/WASM, playable in a browser via a single HTML page with classic ASCII terminal rendering â€” exact mechanical port of all game systems, compiled to WebAssembly and served from demo/rogue/rogue-wasm/www/index.html",
        rankdir=LR,
        default_max_retry=3,
        retry_target="impl_game_loop_integration",
        fallback_retry_target="impl_wasm_bridge",
        default_command_timeout_ms=300000,
        max_command_timeout_ms=1800000,
        provenance_version="1",
        provenance_file_1="path=demo/rogue/original-rogue;git_sha=9673c3a4",
        provenance_file_2="path=demo/rogue/rogue_fast.dot;git_sha=9673c3a4",
        model_stylesheet="
            * { llm_model: glm-4.7; llm_provider: zai; reasoning_effort: high; }
            .hard { llm_model: glm-4.7; llm_provider: zai; reasoning_effort: high; }
            .verify { llm_model: glm-4.7; llm_provider: zai; reasoning_effort: high; }
            .review { llm_model: glm-4.7; llm_provider: zai; reasoning_effort: high; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit  [shape=Msquare, label="Exit"]

    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="bash -lc 'set -euo pipefail; command -v cargo >/dev/null || { echo \"missing required tool: cargo (install via rustup.rs)\" >&2; exit 1; }; command -v rustup >/dev/null || { echo \"missing required tool: rustup (install via rustup.rs)\" >&2; exit 1; }; command -v wasm-pack >/dev/null || { echo \"missing required tool: wasm-pack (install with: cargo install wasm-pack)\" >&2; exit 1; }; rustup target list --installed | grep -qx wasm32-unknown-unknown || { echo \"missing required rust target: wasm32-unknown-unknown (install with: rustup target add wasm32-unknown-unknown)\" >&2; exit 1; }; echo \"toolchain OK\"'"
    ]

    expand_spec [
        shape=box,
        auto_status=true,
        max_agent_turns=24,
        prompt="You are bootstrapping a spec for porting Rogue 5.4.4 from C to Rust/WASM. Produce a detailed implementation spec with module boundaries, acceptance checks, and fidelity criteria.

Read: demo/rogue/original-rogue/ and its C source tree.
Write: .ai/spec.md
Include:
- Disambiguation / Assumptions
- C-to-Rust module mapping
- WASM bridge contract and terminal renderer contract
- Test strategy (unit + integration + wasm-pack build)
- Milestone slices aligned to subsystem boundaries

Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success"
    ]

    impl_analysis [
        shape=box,
        class="hard",
        max_agent_turns=30,
        prompt="Goal: $goal

Create a comprehensive C source analysis baseline.
Read: demo/rogue/original-rogue/*.c and *.h
Write: .ai/rogue_analysis.md

Capture:
- Core structs/unions/macros/constants
- Global state inventory (extern.c/extern.h)
- Function inventory by file
- RNG and turn-loop behavior
- ncurses surface that needs WASM adaptation

Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if analysis is complete, outcome=fail with failure_reason and details otherwise."
    ]

    verify_analysis [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify C analysis coverage and accuracy.

Read: .ai/rogue_analysis.md and demo/rogue/original-rogue/
Check:
1. All major source groups are represented (core, dungeon, combat, items, monsters, player/io, state, platform)
2. RNG formula and turn-loop sequence are correctly documented
3. Global-state summary includes key extern state categories

Write results to .ai/verify_analysis.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if comprehensive and accurate, outcome=fail with failure_reason and details otherwise."
    ]

    check_analysis [shape=diamond, label="Analysis OK?"]

    impl_architecture [
        shape=box,
        class="hard",
        max_agent_turns=30,
        prompt="Goal: $goal

Design executable Rust/WASM architecture using the analysis baseline.
Read: .ai/spec.md, .ai/rogue_analysis.md
Write: .ai/rogue_architecture.md

Define:
- Explicit module responsibilities and interfaces
- Shared state ownership model (GameState and subsystem boundaries)
- WASM API and frontend renderer I/O contract
- Integration seams so each subsequent node edits one dominant subsystem

Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if architecture is complete and consistent, outcome=fail with failure_reason and details otherwise."
    ]

    verify_architecture [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify architecture quality.

Read: .ai/rogue_architecture.md, .ai/rogue_analysis.md
Check:
1. Every C subsystem has a Rust destination
2. Interfaces are concrete enough for isolated implementation slices
3. WASM bridge and renderer contracts are explicit

Write results to .ai/verify_architecture.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if architecture is sufficient, outcome=fail with failure_reason and details otherwise."
    ]

    check_architecture [shape=diamond, label="Arch OK?"]

    impl_scaffold [
        shape=box,
        class="hard",
        max_agent_turns=35,
        max_retries=2,
        prompt="Goal: $goal

Create baseline project scaffold only.
Read: .ai/spec.md, .ai/rogue_architecture.md
Create/modify in demo/rogue/rogue-wasm/:
- Cargo.toml, .gitignore
- src/lib.rs, src/types.rs, src/rng.rs, src/game.rs
- stub modules with compileable interfaces
- www/index.html minimal WASM bootstrap shell

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib

Write implementation log to .ai/port_scaffold.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if build passes, outcome=fail with failure_reason and details otherwise."
    ]

    verify_scaffold [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify scaffold correctness.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Check: core files and stub modules exist; no build artifact pollution in git diff.
Write results to .ai/verify_scaffold.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if all checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_scaffold [shape=diamond, label="Scaffold OK?"]

    impl_dungeon [
        shape=box,
        class="hard",
        max_agent_turns=40,
        max_retries=1,
        prompt="Goal: $goal

Implement dungeon generation slice only.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{rooms.c,passages.c,new_level.c}
Modify: demo/rogue/rogue-wasm/src/dungeon.rs and dependent interfaces only.

Port:
- room grid generation
- corridor generation
- stair placement and level setup hooks

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test dungeon

Write implementation log to .ai/port_dungeon.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_dungeon [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify dungeon slice fidelity.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test dungeon
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Spot-check against C algorithm behavior for room topology and corridor flow.
Write results to .ai/verify_dungeon.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_dungeon [shape=diamond, label="Dungeon OK?"]

    impl_combat [
        shape=box,
        class="hard",
        max_agent_turns=40,
        max_retries=1,
        prompt="Goal: $goal

Implement combat mechanics slice only.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{fight.c,weapons.c,armor.c}
Modify: demo/rogue/rogue-wasm/src/combat.rs and minimal interface points.

Include:
- hit/swing/roll_em core combat math
- attack/fight flow and XP/level hooks

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test combat

Write implementation log to .ai/port_combat.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_combat [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify combat slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test combat
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Validate combat formulas and major flow match C intent.
Write results to .ai/verify_combat.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_combat [shape=diamond, label="Combat OK?"]

    impl_items [
        shape=box,
        class="hard",
        max_agent_turns=40,
        max_retries=1,
        prompt="Goal: $goal

Implement item system slice only.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{things.c,potions.c,scrolls.c,rings.c,sticks.c}
Modify: demo/rogue/rogue-wasm/src/items.rs and minimal interface points.

Include:
- item tables and weighted generation
- core consume/use flows for potions/scrolls/rings/sticks
- inventory naming basics needed for integration

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test items

Write implementation log to .ai/port_items.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_items [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify item slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test items
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Validate table coverage and representative effect behavior.
Write results to .ai/verify_items.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_items [shape=diamond, label="Items OK?"]

    impl_monsters [
        shape=box,
        class="hard",
        max_agent_turns=40,
        max_retries=1,
        prompt="Goal: $goal

Implement monster table + chase AI slice.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{monsters.c,chase.c}
Modify: demo/rogue/rogue-wasm/src/monsters.rs and minimal interface points.

Include:
- A-Z monster table representation
- spawn/selection helpers
- chase movement primitives

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test monsters

Write implementation log to .ai/port_monsters.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_monsters [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify monsters slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test monsters
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Validate monster table coverage and chase flow parity.
Write results to .ai/verify_monsters.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_monsters [shape=diamond, label="Monsters OK?"]

    impl_daemons [
        shape=box,
        class="hard",
        max_agent_turns=35,
        max_retries=1,
        prompt="Goal: $goal

Implement daemon/fuse scheduling slice.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{daemon.c,daemons.c}
Modify: demo/rogue/rogue-wasm/src/daemon.rs and minimal interface points.

Include lifecycle operations and core callbacks used by turn-loop and hunger/regen behavior.

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test daemon

Write implementation log to .ai/port_daemons.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_daemons [
        shape=box,
        class="verify",
        max_agent_turns=16,
        prompt="Verify daemon slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test daemon
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Validate timing/scheduling behavior at a representative level.
Write results to .ai/verify_daemons.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_daemons [shape=diamond, label="Daemons OK?"]

    impl_player_commands [
        shape=box,
        class="hard",
        max_agent_turns=40,
        max_retries=1,
        prompt="Goal: $goal

Implement player command and movement slice.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{command.c,move.c,pack.c}
Modify: demo/rogue/rogue-wasm/src/player.rs and minimal interface points.

Include movement keys, command dispatch, and map interaction hooks needed for gameplay.

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test player

Write implementation log to .ai/port_player_commands.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_player_commands [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify player command slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test player
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Check representative command mappings and movement invariants.
Write results to .ai/verify_player_commands.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_player_commands [shape=diamond, label="Player Cmd OK?"]

    impl_io_state [
        shape=box,
        class="hard",
        max_agent_turns=35,
        max_retries=1,
        prompt="Goal: $goal

Implement io/state slice for WASM context.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{io.c,save.c,state.c,list.c}
Modify: demo/rogue/rogue-wasm/src/io_bridge.rs and src/state.rs.

Include message/status output abstraction, and save/load serialization contract.

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test state io

Write implementation log to .ai/port_io_state.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_io_state [
        shape=box,
        class="verify",
        max_agent_turns=16,
        prompt="Verify io/state slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test state io
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Check save/load roundtrip and message/status contracts.
Write results to .ai/verify_io_state.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_io_state [shape=diamond, label="IO/State OK?"]

    impl_init_score_wizard [
        shape=box,
        class="hard",
        max_agent_turns=30,
        max_retries=1,
        prompt="Goal: $goal

Implement init/score/wizard slice.
Read: .ai/rogue_architecture.md, demo/rogue/original-rogue/{init.c,options.c,rip.c,wizard.c}
Modify: demo/rogue/rogue-wasm/src/init.rs, src/score.rs, src/wizard.rs.

Include deterministic init flows, scoring/death surface, and wizard hooks.

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib && cargo test init score wizard

Write implementation log to .ai/port_init_score_wizard.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if compile/tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_init_score_wizard [
        shape=box,
        class="verify",
        max_agent_turns=16,
        prompt="Verify init/score/wizard slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test init score wizard
3. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Check baseline stat/init behavior and death/score surface parity.
Write results to .ai/verify_init_score_wizard.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_init_score_wizard [shape=diamond, label="Init/Score OK?"]

    impl_wasm_bridge [
        shape=box,
        class="hard",
        max_agent_turns=30,
        max_retries=1,
        prompt="Goal: $goal

Implement WASM boundary + frontend renderer slice.
Read: .ai/rogue_architecture.md
Modify: demo/rogue/rogue-wasm/src/lib.rs and demo/rogue/rogue-wasm/www/index.html.

Include:
- stable exported API (new/process_key/save/load)
- browser keyboard mapping and render loop contract over returned frame data

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib
- cd demo/rogue/rogue-wasm && wasm-pack build --target web

Write implementation log to .ai/port_wasm_bridge.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if build passes, outcome=fail with failure_reason and details otherwise."
    ]

    verify_wasm_bridge [
        shape=box,
        class="verify",
        max_agent_turns=16,
        prompt="Verify WASM bridge slice.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && wasm-pack build --target web
3. changed=$(git diff --name-only $base_sha -- '*.rs' '*.js' '*.html' '*.css'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings; fi

Check exported API shape and index.html import/render wiring.
Write results to .ai/verify_wasm_bridge.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_wasm_bridge [shape=diamond, label="WASM Bridge OK?"]

    impl_game_loop_integration [
        shape=box,
        class="hard",
        max_agent_turns=40,
        max_retries=1,
        prompt="Goal: $goal

Integrate subsystem slices into a coherent gameplay loop.
Read: .ai/rogue_architecture.md and all prior .ai/port_*.md logs.
Modify: demo/rogue/rogue-wasm/src/game.rs and minimal glue across subsystem boundaries.

Integrate:
- per-turn sequencing
- cross-module call flow
- daemon/fuse hooks and message/status updates

Acceptance:
- cd demo/rogue/rogue-wasm && cargo build --lib
- cd demo/rogue/rogue-wasm && cargo test
- cd demo/rogue/rogue-wasm && wasm-pack build --target web

Write implementation log to .ai/integration_log.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_game_loop_integration [
        shape=box,
        class="verify",
        max_agent_turns=18,
        prompt="Verify integrated gameplay loop.

Run:
1. cd demo/rogue/rogue-wasm && cargo build --lib
2. cd demo/rogue/rogue-wasm && cargo test
3. cd demo/rogue/rogue-wasm && wasm-pack build --target web
4. changed=$(git diff --name-only $base_sha -- '*.rs'); if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib --tests -- -D warnings; fi

Check representative key-flow: input -> state update -> frame render payload.
Write results to .ai/verify_integration.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if all checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_game_loop_integration [shape=diamond, label="Integration OK?"]

    impl_qa [
        shape=box,
        class="hard",
        max_agent_turns=30,
        prompt="Goal: $goal

Add and run focused QA suite.
Read: .ai/rogue_analysis.md and implemented Rust modules.
Add/expand tests for:
- RNG determinism
- dungeon and monster invariants
- combat and item sanity
- save/load roundtrip
- integration key-path behavior

Run:
- cd demo/rogue/rogue-wasm && cargo test
- cd demo/rogue/rogue-wasm && wasm-pack test --node || echo \"wasm-pack test unavailable\"

Write results to .ai/qa_results.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_qa [
        shape=box,
        class="verify",
        max_agent_turns=16,
        prompt="Verify QA results.

Run:
1. cd demo/rogue/rogue-wasm && cargo test
2. cd demo/rogue/rogue-wasm && wasm-pack test --node || echo \"wasm-pack test unavailable\"
3. Verify .ai/qa_results.md documents pass/fail by category

Write results to .ai/verify_qa.md.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if all required checks pass, outcome=fail with failure_reason and details otherwise."
    ]

    check_qa [shape=diamond, label="QA OK?"]

    review [
        shape=box,
        class="review",
        goal_gate=true,
        max_agent_turns=30,
        prompt="Goal: $goal

Perform final review against spec and artifacts.
Read: .ai/spec.md, .ai/rogue_analysis.md, .ai/rogue_architecture.md, .ai/qa_results.md, .ai/verify_*.md
Read: demo/rogue/rogue-wasm/src/* and demo/rogue/rogue-wasm/www/index.html

Required checks:
- cd demo/rogue/rogue-wasm && cargo test
- cd demo/rogue/rogue-wasm && wasm-pack build --target web

Write detailed review to .ai/final_review.md including any remaining fidelity gaps.
Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.
Write status JSON: outcome=success if complete/playable/fidelity-acceptable, outcome=fail with failure_reason and details otherwise."
    ]

    check_review [shape=diamond, label="Review OK?"]

    start -> check_toolchain
    check_toolchain -> expand_spec                  [condition="outcome=success"]

    expand_spec -> impl_analysis
    impl_analysis -> verify_analysis -> check_analysis
    check_analysis -> impl_architecture             [condition="outcome=success"]
    check_analysis -> impl_analysis                 [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_analysis -> impl_analysis                 [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_architecture -> verify_architecture -> check_architecture
    check_architecture -> impl_scaffold             [condition="outcome=success"]
    check_architecture -> impl_architecture         [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_architecture -> impl_architecture         [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_scaffold -> verify_scaffold -> check_scaffold
    check_scaffold -> impl_dungeon                  [condition="outcome=success"]
    check_scaffold -> impl_scaffold                 [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_scaffold -> impl_scaffold                 [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_dungeon -> verify_dungeon -> check_dungeon
    check_dungeon -> impl_combat                    [condition="outcome=success"]
    check_dungeon -> impl_dungeon                   [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_dungeon -> impl_dungeon                   [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_combat -> verify_combat -> check_combat
    check_combat -> impl_items                      [condition="outcome=success"]
    check_combat -> impl_combat                     [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_combat -> impl_combat                     [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_items -> verify_items -> check_items
    check_items -> impl_monsters                    [condition="outcome=success"]
    check_items -> impl_items                       [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_items -> impl_items                       [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_monsters -> verify_monsters -> check_monsters
    check_monsters -> impl_daemons                  [condition="outcome=success"]
    check_monsters -> impl_monsters                 [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_monsters -> impl_monsters                 [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_daemons -> verify_daemons -> check_daemons
    check_daemons -> impl_player_commands           [condition="outcome=success"]
    check_daemons -> impl_daemons                   [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_daemons -> impl_daemons                   [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_player_commands -> verify_player_commands -> check_player_commands
    check_player_commands -> impl_io_state          [condition="outcome=success"]
    check_player_commands -> impl_player_commands   [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_player_commands -> impl_player_commands   [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_io_state -> verify_io_state -> check_io_state
    check_io_state -> impl_init_score_wizard        [condition="outcome=success"]
    check_io_state -> impl_io_state                 [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_io_state -> impl_io_state                 [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_init_score_wizard -> verify_init_score_wizard -> check_init_score_wizard
    check_init_score_wizard -> impl_wasm_bridge     [condition="outcome=success"]
    check_init_score_wizard -> impl_init_score_wizard [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_init_score_wizard -> impl_init_score_wizard [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_wasm_bridge -> verify_wasm_bridge -> check_wasm_bridge
    check_wasm_bridge -> impl_game_loop_integration [condition="outcome=success"]
    check_wasm_bridge -> impl_wasm_bridge           [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_wasm_bridge -> impl_wasm_bridge           [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_game_loop_integration -> verify_game_loop_integration -> check_game_loop_integration
    check_game_loop_integration -> impl_qa          [condition="outcome=success"]
    check_game_loop_integration -> impl_game_loop_integration [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_game_loop_integration -> impl_game_loop_integration [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    impl_qa -> verify_qa -> check_qa
    check_qa -> review                              [condition="outcome=success"]
    check_qa -> impl_qa                             [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_qa -> impl_qa                             [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    review -> check_review
    check_review -> exit                            [condition="outcome=success"]
    check_review -> impl_game_loop_integration      [condition="outcome=fail && context.failure_class=transient_infra", label="fix-infra", loop_restart=true]
    check_review -> impl_game_loop_integration      [condition="outcome=fail && context.failure_class!=transient_infra", label="fix"]
}
